{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(rootSaga);\n\n// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\n// 예를 들어\n// const gen = function* () {\n//   console.log(1);\n//   yield;\n//   console.log(2);\n//   yield;\n//   console.log(3);\n//   yield 4;\n// }\n// 이런 제너레이터가 있다면\n// gen()의 결과는 {<suspended>}\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\n// saga는 이것을 이용해 이벤트 리스너처럼 작동하게 한다. 로그인 액션이 들어오면 로그인을 실행하는 등...\n// reducers/user.js의 주석(thunk)과 같은 일을 하는 것\nimport { all, fork, call, put, takeLatest, throttle, delay } from \"redux-saga/effects\"; // 이것들을 saga effect라고 한다.\n// 사가를 쪼갤 때는 리듀서랑 비슷한 기준으로 쪼개면 된다.\n// 다행히 컴바인하는건 따로 없고 그냥 export import로 가능\n\nimport postSaga from \"./post\";\nimport userSaga from \"./user\";\nexport default function rootSaga() {\n  return _regeneratorRuntime.wrap(function rootSaga$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return all([fork(postSaga), fork(userSaga)]);\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}","map":{"version":3,"sources":["D:/__My_crafts/Algorithms For Coding Test/Other Knowledges for interview/Next/CloneTwitter/prepare/front/sagas/index.js"],"names":["rootSaga","all","fork","call","put","takeLatest","throttle","delay","postSaga","userSaga"],"mappings":";;oDAuCyBA,Q;;AAvCzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA,SACEC,GADF,EAEEC,IAFF,EAGEC,IAHF,EAIEC,GAJF,EAKEC,UALF,EAMEC,QANF,EAOEC,KAPF,QAQO,oBARP,C,CASA;AACA;AACA;;AACA,OAAOC,QAAP,MAAqB,QAArB;AACA,OAAOC,QAAP,MAAqB,QAArB;AAEA,eAAe,SAAUT,QAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAGb,iBAAMC,GAAG,CAAC,CAACC,IAAI,CAACM,QAAD,CAAL,EAAiBN,IAAI,CAACO,QAAD,CAArB,CAAD,CAAT;;AAHa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\r\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\r\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\r\n// 예를 들어\r\n// const gen = function* () {\r\n//   console.log(1);\r\n//   yield;\r\n//   console.log(2);\r\n//   yield;\r\n//   console.log(3);\r\n//   yield 4;\r\n// }\r\n// 이런 제너레이터가 있다면\r\n// gen()의 결과는 {<suspended>}\r\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\r\n\r\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\r\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\r\n// saga는 이것을 이용해 이벤트 리스너처럼 작동하게 한다. 로그인 액션이 들어오면 로그인을 실행하는 등...\r\n// reducers/user.js의 주석(thunk)과 같은 일을 하는 것\r\n\r\nimport {\r\n  all,\r\n  fork,\r\n  call,\r\n  put,\r\n  takeLatest,\r\n  throttle,\r\n  delay,\r\n} from \"redux-saga/effects\";\r\n// 이것들을 saga effect라고 한다.\r\n// 사가를 쪼갤 때는 리듀서랑 비슷한 기준으로 쪼개면 된다.\r\n// 다행히 컴바인하는건 따로 없고 그냥 export import로 가능\r\nimport postSaga from \"./post\";\r\nimport userSaga from \"./user\";\r\n\r\nexport default function* rootSaga() {\r\n  // all은 배열을 받아서 배열 안의 것들을 한 번에(동시에) 실행시켜 준다.\r\n  // fork는 해당 함수를 실행시킨다.\r\n  yield all([fork(postSaga), fork(userSaga)]);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}