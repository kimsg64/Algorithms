{"ast":null,"code":"// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\n// 예를 들어\n// const gen = function* () {\n//   console.log(1);\n//   yield;\n//   console.log(2);\n//   yield;\n//   console.log(3);\n//   yield 4;\n// }\n// 이런 제너레이터가 있다면\n// gen()의 결과는 {<suspended>}\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\n// saga는 이것을 이용해 이벤트 리스너처럼 작동하게 한다. 로그인 액션이 들어오면 로그인을 실행하는 등...\n// reducers/user.js의 주석(thunk)과 같은 일을 하는 것\nimport { all, fork, take, call, put } from \"redux-saga/effects\"; // 이것들을 saga effect라고 한다.\n\nimport axios from \"axios\";\n\nfunction logInAPI() {\n  // 실제로 서버에 요청(제너레이터 아님)\n  return axios.post(\"/api/login\");\n}\n\nfunction* logIn() {\n  try {\n    // call도 해당 함수를 실행시키는데, fork와 약간 다르다.\n    // fork는 비동기 함수 호출, call은 동기 함수 호출이다.\n    // 즉 여기서 yield call 대신 yield fork를 써버리면, loginAPI의 결과가 result에 담기기 전에 바로 다음 줄로 넘어가 버린다.\n    // call을 하면 앞의 logInAPI가 완료될 때까지 실행되지 않는다.\n    // 즉 call은 axios.post().then(res => res)처럼 작동하지만, fork를 여기서 쓰면 axios.post() 뒤에 res가 없는데 res를 찾는 꼴이 됨\n    const result = yield call(logInAPI); // put은 dispatch같은 것이다.\n\n    yield put({\n      type: \"LOG_IN_SUCCESS\",\n      data: result.data\n    });\n  } catch (err) {\n    yield put({\n      type: \"LOG_IN_FAILURE\",\n      data: err.response.data\n    });\n  }\n}\n\nfunction* watchLogIn() {\n  // take는 해당 액션이 실행될 때까지 기다렸다가 두 번째 인자로 전달된 함수를 실행시킨다.\n  yield take(\"LOG_IN_REQUEST\", logIn);\n}\n\nfunction* watchLogOut() {\n  yield take(\"LOG_OUT_REQUEST\");\n}\n\nfunction* watchAddPost() {\n  yield take(\"ADD_POST_REQUEST\");\n}\n\nexport default function* rootSaga() {\n  // all은 배열을 받아서 배열 안의 것들을 한 번에(동시에) 실행시켜 준다.\n  // fork는 해당 함수를 실행시킨다.\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\n}","map":{"version":3,"sources":["D:/__My_crafts/Algorithms For Coding Test/Other Knowledges for interview/Next/CloneTwitter/prepare/front/sagas/index.js"],"names":["all","fork","take","call","put","axios","logInAPI","post","logIn","result","type","data","err","response","watchLogIn","watchLogOut","watchAddPost","rootSaga"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA,SAASA,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,IAA1B,EAAgCC,GAAhC,QAA2C,oBAA3C,C,CACA;;AACA,OAAOC,KAAP,MAAkB,OAAlB;;AAEA,SAASC,QAAT,GAAoB;AAClB;AACA,SAAOD,KAAK,CAACE,IAAN,CAAW,YAAX,CAAP;AACD;;AAED,UAAUC,KAAV,GAAkB;AAChB,MAAI;AACF;AACA;AACA;AACA;AACA;AACA,UAAMC,MAAM,GAAG,MAAMN,IAAI,CAACG,QAAD,CAAzB,CANE,CAOF;;AACA,UAAMF,GAAG,CAAC;AACRM,MAAAA,IAAI,EAAE,gBADE;AAERC,MAAAA,IAAI,EAAEF,MAAM,CAACE;AAFL,KAAD,CAAT;AAID,GAZD,CAYE,OAAOC,GAAP,EAAY;AACZ,UAAMR,GAAG,CAAC;AACRM,MAAAA,IAAI,EAAE,gBADE;AAERC,MAAAA,IAAI,EAAEC,GAAG,CAACC,QAAJ,CAAaF;AAFX,KAAD,CAAT;AAID;AACF;;AAED,UAAUG,UAAV,GAAuB;AACrB;AACA,QAAMZ,IAAI,CAAC,gBAAD,EAAmBM,KAAnB,CAAV;AACD;;AAED,UAAUO,WAAV,GAAwB;AACtB,QAAMb,IAAI,CAAC,iBAAD,CAAV;AACD;;AAED,UAAUc,YAAV,GAAyB;AACvB,QAAMd,IAAI,CAAC,kBAAD,CAAV;AACD;;AAED,eAAe,UAAUe,QAAV,GAAqB;AAClC;AACA;AACA,QAAMjB,GAAG,CAAC,CAACC,IAAI,CAACa,UAAD,CAAL,EAAmBb,IAAI,CAACc,WAAD,CAAvB,EAAsCd,IAAI,CAACe,YAAD,CAA1C,CAAD,CAAT;AACD","sourcesContent":["// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\r\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\r\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\r\n// 예를 들어\r\n// const gen = function* () {\r\n//   console.log(1);\r\n//   yield;\r\n//   console.log(2);\r\n//   yield;\r\n//   console.log(3);\r\n//   yield 4;\r\n// }\r\n// 이런 제너레이터가 있다면\r\n// gen()의 결과는 {<suspended>}\r\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\r\n\r\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\r\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\r\n// saga는 이것을 이용해 이벤트 리스너처럼 작동하게 한다. 로그인 액션이 들어오면 로그인을 실행하는 등...\r\n// reducers/user.js의 주석(thunk)과 같은 일을 하는 것\r\n\r\nimport { all, fork, take, call, put } from \"redux-saga/effects\";\r\n// 이것들을 saga effect라고 한다.\r\nimport axios from \"axios\";\r\n\r\nfunction logInAPI() {\r\n  // 실제로 서버에 요청(제너레이터 아님)\r\n  return axios.post(\"/api/login\");\r\n}\r\n\r\nfunction* logIn() {\r\n  try {\r\n    // call도 해당 함수를 실행시키는데, fork와 약간 다르다.\r\n    // fork는 비동기 함수 호출, call은 동기 함수 호출이다.\r\n    // 즉 여기서 yield call 대신 yield fork를 써버리면, loginAPI의 결과가 result에 담기기 전에 바로 다음 줄로 넘어가 버린다.\r\n    // call을 하면 앞의 logInAPI가 완료될 때까지 실행되지 않는다.\r\n    // 즉 call은 axios.post().then(res => res)처럼 작동하지만, fork를 여기서 쓰면 axios.post() 뒤에 res가 없는데 res를 찾는 꼴이 됨\r\n    const result = yield call(logInAPI);\r\n    // put은 dispatch같은 것이다.\r\n    yield put({\r\n      type: \"LOG_IN_SUCCESS\",\r\n      data: result.data,\r\n    });\r\n  } catch (err) {\r\n    yield put({\r\n      type: \"LOG_IN_FAILURE\",\r\n      data: err.response.data,\r\n    });\r\n  }\r\n}\r\n\r\nfunction* watchLogIn() {\r\n  // take는 해당 액션이 실행될 때까지 기다렸다가 두 번째 인자로 전달된 함수를 실행시킨다.\r\n  yield take(\"LOG_IN_REQUEST\", logIn);\r\n}\r\n\r\nfunction* watchLogOut() {\r\n  yield take(\"LOG_OUT_REQUEST\");\r\n}\r\n\r\nfunction* watchAddPost() {\r\n  yield take(\"ADD_POST_REQUEST\");\r\n}\r\n\r\nexport default function* rootSaga() {\r\n  // all은 배열을 받아서 배열 안의 것들을 한 번에(동시에) 실행시켜 준다.\r\n  // fork는 해당 함수를 실행시킨다.\r\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}