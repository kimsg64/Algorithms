{"ast":null,"code":"// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\n// 예를 들어\n// const gen = function* () {\n//   console.log(1);\n//   yield;\n//   console.log(2);\n//   yield;\n//   console.log(3);\n//   yield 4;\n// }\n// 이런 제너레이터가 있다면\n// gen()의 결과는 {<suspended>}\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\nimport { all, fork, take, call, put } from \"redux-saga/effects\"; // 이것들을 saga effect라고 한다.\n\nimport axios from \"axios\";\n\nfunction logInAPI() {\n  // 실제로 서버에 요청(제너레이터 아님)\n  return axios.post(\"/api/login\");\n}\n\nfunction* logIn() {\n  try {\n    // call도 해당 함수를 실행시키는데, fork와 약간 다르다. (추후 알아볼 것)\n    const result = yield call(logInAPI); // put은\n\n    yield put({\n      type: \"LOG_IN_SUCCESS\",\n      data: result.data\n    });\n  } catch {}\n}\n\nfunction* watchLogIn() {\n  // take는 해당 액션이 실행될 때까지 기다렸다가 두 번째 인자로 전달된 함수를 실행시킨다.\n  yield take(\"LOG_IN\", logIn);\n}\n\nfunction* watchLogOut() {\n  yield take(\"LOG_OUT\");\n}\n\nfunction* watchAddPost() {\n  yield take(\"ADD_POST\");\n}\n\nexport default function* rootSaga() {\n  // all은 배열을 받아서 배열 안의 것들을 한 번에(동시에) 실행시켜 준다.\n  // fork는 해당 함수를 실행시킨다.\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\n}","map":{"version":3,"sources":["D:/__My_crafts/Algorithms For Coding Test/Other Knowledges for interview/Next/CloneTwitter/prepare/front/sagas/index.js"],"names":["all","fork","take","call","put","axios","logInAPI","post","logIn","result","type","data","watchLogIn","watchLogOut","watchAddPost","rootSaga"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA,SAASA,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,IAA1B,EAAgCC,GAAhC,QAA2C,oBAA3C,C,CACA;;AACA,OAAOC,KAAP,MAAkB,OAAlB;;AAEA,SAASC,QAAT,GAAoB;AAClB;AACA,SAAOD,KAAK,CAACE,IAAN,CAAW,YAAX,CAAP;AACD;;AAED,UAAUC,KAAV,GAAkB;AAChB,MAAI;AACF;AACA,UAAMC,MAAM,GAAG,MAAMN,IAAI,CAACG,QAAD,CAAzB,CAFE,CAGF;;AACA,UAAMF,GAAG,CAAC;AACRM,MAAAA,IAAI,EAAE,gBADE;AAERC,MAAAA,IAAI,EAAEF,MAAM,CAACE;AAFL,KAAD,CAAT;AAID,GARD,CAQE,MAAM,CAAE;AACX;;AAED,UAAUC,UAAV,GAAuB;AACrB;AACA,QAAMV,IAAI,CAAC,QAAD,EAAWM,KAAX,CAAV;AACD;;AAED,UAAUK,WAAV,GAAwB;AACtB,QAAMX,IAAI,CAAC,SAAD,CAAV;AACD;;AAED,UAAUY,YAAV,GAAyB;AACvB,QAAMZ,IAAI,CAAC,UAAD,CAAV;AACD;;AAED,eAAe,UAAUa,QAAV,GAAqB;AAClC;AACA;AACA,QAAMf,GAAG,CAAC,CAACC,IAAI,CAACW,UAAD,CAAL,EAAmBX,IAAI,CAACY,WAAD,CAAvB,EAAsCZ,IAAI,CAACa,YAAD,CAA1C,CAAD,CAAT;AACD","sourcesContent":["// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\r\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\r\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\r\n// 예를 들어\r\n// const gen = function* () {\r\n//   console.log(1);\r\n//   yield;\r\n//   console.log(2);\r\n//   yield;\r\n//   console.log(3);\r\n//   yield 4;\r\n// }\r\n// 이런 제너레이터가 있다면\r\n// gen()의 결과는 {<suspended>}\r\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\r\n\r\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\r\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\r\n\r\nimport { all, fork, take, call, put } from \"redux-saga/effects\";\r\n// 이것들을 saga effect라고 한다.\r\nimport axios from \"axios\";\r\n\r\nfunction logInAPI() {\r\n  // 실제로 서버에 요청(제너레이터 아님)\r\n  return axios.post(\"/api/login\");\r\n}\r\n\r\nfunction* logIn() {\r\n  try {\r\n    // call도 해당 함수를 실행시키는데, fork와 약간 다르다. (추후 알아볼 것)\r\n    const result = yield call(logInAPI);\r\n    // put은\r\n    yield put({\r\n      type: \"LOG_IN_SUCCESS\",\r\n      data: result.data,\r\n    });\r\n  } catch {}\r\n}\r\n\r\nfunction* watchLogIn() {\r\n  // take는 해당 액션이 실행될 때까지 기다렸다가 두 번째 인자로 전달된 함수를 실행시킨다.\r\n  yield take(\"LOG_IN\", logIn);\r\n}\r\n\r\nfunction* watchLogOut() {\r\n  yield take(\"LOG_OUT\");\r\n}\r\n\r\nfunction* watchAddPost() {\r\n  yield take(\"ADD_POST\");\r\n}\r\n\r\nexport default function* rootSaga() {\r\n  // all은 배열을 받아서 배열 안의 것들을 한 번에(동시에) 실행시켜 준다.\r\n  // fork는 해당 함수를 실행시킨다.\r\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}