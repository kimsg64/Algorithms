{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(watchLogIn),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(watchLogOut),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(watchAddPost),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(rootSaga);\n\n// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\n// 예를 들어\n// const gen = function* () {\n//   console.log(1);\n//   yield;\n//   console.log(2);\n//   yield;\n//   console.log(3);\n//   yield 4;\n// }\n// 이런 제너레이터가 있다면\n// gen()의 결과는 {<suspended>}\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\nimport { all, fork, take, call, put } from \"redux-saga/effects\"; // 이것들을 saga effect라고 한다.\n\nfunction watchLogIn() {\n  return _regeneratorRuntime.wrap(function watchLogIn$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return take(\"LOG_IN\");\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction watchLogOut() {\n  return _regeneratorRuntime.wrap(function watchLogOut$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return take(\"LOG_OUT\");\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nfunction watchAddPost() {\n  return _regeneratorRuntime.wrap(function watchAddPost$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return take(\"ADD_POST\");\n\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n}\n\nexport default function rootSaga() {\n  return _regeneratorRuntime.wrap(function rootSaga$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\n\n        case 2:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}","map":{"version":3,"sources":["D:/__My_crafts/Algorithms For Coding Test/Other Knowledges for interview/Next/CloneTwitter/prepare/front/sagas/index.js"],"names":["watchLogIn","watchLogOut","watchAddPost","rootSaga","all","fork","take","call","put"],"mappings":";;oDAyBUA,U;qDAIAC,W;qDAIAC,Y;qDAIeC,Q;;AArCzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA,SAASC,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,IAA1B,EAAgCC,GAAhC,QAA2C,oBAA3C,C,CACA;;AAEA,SAAUR,UAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,iBAAMM,IAAI,CAAC,QAAD,CAAV;;AADF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA,SAAUL,WAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,iBAAMK,IAAI,CAAC,SAAD,CAAV;;AADF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA,SAAUJ,YAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,iBAAMI,IAAI,CAAC,UAAD,CAAV;;AADF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA,eAAe,SAAUH,QAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAEb,iBAAMC,GAAG,CAAC,CAACC,IAAI,CAACL,UAAD,CAAL,EAAmBK,IAAI,CAACJ,WAAD,CAAvB,EAAsCI,IAAI,CAACH,YAAD,CAA1C,CAAD,CAAT;;AAFa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\r\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\r\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\r\n// 예를 들어\r\n// const gen = function* () {\r\n//   console.log(1);\r\n//   yield;\r\n//   console.log(2);\r\n//   yield;\r\n//   console.log(3);\r\n//   yield 4;\r\n// }\r\n// 이런 제너레이터가 있다면\r\n// gen()의 결과는 {<suspended>}\r\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\r\n\r\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\r\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\r\n\r\nimport { all, fork, take, call, put } from \"redux-saga/effects\";\r\n// 이것들을 saga effect라고 한다.\r\n\r\nfunction* watchLogIn() {\r\n  yield take(\"LOG_IN\");\r\n}\r\n\r\nfunction* watchLogOut() {\r\n  yield take(\"LOG_OUT\");\r\n}\r\n\r\nfunction* watchAddPost() {\r\n  yield take(\"ADD_POST\");\r\n}\r\n\r\nexport default function* rootSaga() {\r\n  // all은 배열을 받아서 배열 안의 것들을 한 번에 실행시켜 준다.\r\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}