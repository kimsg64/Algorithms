{"ast":null,"code":"// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\n// 예를 들어\n// const gen = function* () {\n//   console.log(1);\n//   yield;\n//   console.log(2);\n//   yield;\n//   console.log(3);\n//   yield 4;\n// }\n// 이런 제너레이터가 있다면\n// gen()의 결과는 {<suspended>}\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\nimport { all, fork, take, call, put } from \"redux-saga/effects\"; // 이것들을 saga effect라고 한다.\n\nfunction* watchLogIn() {\n  yield take(\"LOG_IN\");\n}\n\nfunction* watchLogOut() {\n  yield take(\"LOG_OUT\");\n}\n\nfunction* watchAddPost() {\n  yield take(\"ADD_POST\");\n}\n\nexport default function* rootSaga() {\n  // all은 배열을 받아서 배열 안의 것들을 한 번에 실행시켜 준다.\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\n}","map":{"version":3,"sources":["D:/__My_crafts/Algorithms For Coding Test/Other Knowledges for interview/Next/CloneTwitter/prepare/front/sagas/index.js"],"names":["all","fork","take","call","put","watchLogIn","watchLogOut","watchAddPost","rootSaga"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA,SAASA,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,IAA1B,EAAgCC,GAAhC,QAA2C,oBAA3C,C,CACA;;AAEA,UAAUC,UAAV,GAAuB;AACrB,QAAMH,IAAI,CAAC,QAAD,CAAV;AACD;;AAED,UAAUI,WAAV,GAAwB;AACtB,QAAMJ,IAAI,CAAC,SAAD,CAAV;AACD;;AAED,UAAUK,YAAV,GAAyB;AACvB,QAAML,IAAI,CAAC,UAAD,CAAV;AACD;;AAED,eAAe,UAAUM,QAAV,GAAqB;AAClC;AACA,QAAMR,GAAG,CAAC,CAACC,IAAI,CAACI,UAAD,CAAL,EAAmBJ,IAAI,CAACK,WAAD,CAAvB,EAAsCL,IAAI,CAACM,YAAD,CAA1C,CAAD,CAAT;AACD","sourcesContent":["// 제너레이터: 함수 뒤에 *이 붙어 있는 것...\r\n// 제너레이터 안의 것을 실행하려면 .next()로 호출해야 한다. 그냥 제너레이터만 호출하면 suspended가 나옴\r\n// 제너레이터 안의 yield는 무엇이냐... yield 앞까지만 실행됨\r\n// 예를 들어\r\n// const gen = function* () {\r\n//   console.log(1);\r\n//   yield;\r\n//   console.log(2);\r\n//   yield;\r\n//   console.log(3);\r\n//   yield 4;\r\n// }\r\n// 이런 제너레이터가 있다면\r\n// gen()의 결과는 {<suspended>}\r\n// gen().next()를 하면 맨 처음에는 콘솔창에 1이 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 2가 찍히고, 반환값은 {value: undefined, done: false}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 3이 찍히고, 반환값은 {value: 4, done: true}\r\n// 한 번 더 gen().next()를 하면 콘솔창에 아무것도 안찍히고, 반환값은 {value: undefined, done: false}\r\n\r\n// 절대 멈추지 않는 제너레이터가 있는데, while(true) 문이다. 원래 무한 반복되어 프로그램이 중지되어 버리는 while(true)지만, yield가 중단점이 되어버리므로 프로그램이 중단되지 않는다.\r\n// 또 이벤트 리스너와 비슷한 것을 만들 수도 있다. 어떤 코드가 실행되면 next가 실행되도록 하는 ...\r\n\r\nimport { all, fork, take, call, put } from \"redux-saga/effects\";\r\n// 이것들을 saga effect라고 한다.\r\n\r\nfunction* watchLogIn() {\r\n  yield take(\"LOG_IN\");\r\n}\r\n\r\nfunction* watchLogOut() {\r\n  yield take(\"LOG_OUT\");\r\n}\r\n\r\nfunction* watchAddPost() {\r\n  yield take(\"ADD_POST\");\r\n}\r\n\r\nexport default function* rootSaga() {\r\n  // all은 배열을 받아서 배열 안의 것들을 한 번에 실행시켜 준다.\r\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}