/*
<두 정수 사이의 합>
두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.
예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.

제한 조건
a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.
a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.
a와 b의 대소관계는 정해져있지 않습니다.

<나의 풀이>
가우스 형님의 시그마 계산법으로 풀기
계산 순서를 제대로 적지 않으면 오버플로우가 발생하므로 괄호를 잘 붙여야 한다.
(long)((a+b)*((b-a+1)/2.0)) => 잘 됨
(long)(((a+b)*(b-a+1)/2.0)) => 이 경우 (a+b)*(b-a+1)이 먼저 계산되어 오버플로우가 발생함

사실 이거 안하고 반복문 쓰면 코드 자체는 더 간단할 것 같다.

반복문을 쓰면 a와 b 사이의 숫자가 많아질수록 시간이 더 걸리므로 시간 복잡도가 O(N),
가우스 형님의 계산법을 쓰면 a와 b의 값에 관계없이 동일한 식을 수행하므로 시간 복잡도가 O(1)이 되어서
아마 성능상으로는 아주 약간 위일 것

*/
public class Sigma {
    public static long solution(int a, int b) {
        long answer = b > a ? (long)((a+b)*((b-a+1)/2.0)) : a > b ? (long)((a+b)*((a-b+1)/2.0)) : a;
        return answer;
    }
}
